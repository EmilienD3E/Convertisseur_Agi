# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ConvertisseurAgi
                                 A QGIS plugin
 Convertisseur SHP/JSON/GPKG vers AGI
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-03-04
        git sha              : $Format:%H$
        copyright            : (C) 2025 by D3E Electronique
        email                : emilien.coustillas@d3e.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import xml.dom.minidom as minidom
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from PyQt5.QtWidgets import QAction, QListWidgetItem, QFileDialog, QMessageBox
from qgis.PyQt.QtGui import QIcon
from qgis.core import (QgsProject, QgsMapLayer, QgsVectorLayer, QgsWkbTypes, Qgis,
                       QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsGeometry)
from PyQt5.QtCore import Qt, QVariant

# Import the dialog
from .Convertisseur_Agi_dialog import ConvertisseurAgiDialog

class ConvertisseurAgi:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Convertisseur AGI')
        self.first_start = True
        self.plugin_dir = os.path.dirname(__file__)

        # Locale setup
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            f'ConvertisseurAgi_{locale}.qm'
        )

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Dialog related attributes
        self.dlg = None
        self.ui = None
        self.create_form = False

    def tr(self, message):
        """Get the translation for a string.

        :param message: String for translation.
        :type message: str
        :returns: Translated version of message
        :rtype: str
        """
        return QCoreApplication.translate('ConvertisseurAgi', message)

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""
        icon_path = ':/plugins/Convertisseur_Agi/icon.png'

        self.action = QAction(QIcon(icon_path), self.tr(u'Convertisseur AGI'), self.iface.mainWindow())

        # Connect the action to the run method
        self.action.triggered.connect(self.run)

        # Add the action to the toolbar and menu
        self.iface.addToolBarIcon(self.action)
        self.iface.addPluginToMenu(self.menu, self.action)

        # Add to actions list
        self.actions.append(self.action)

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(self.menu, action)
            self.iface.removeToolBarIcon(action)

    def run(self):
        """Run method that performs all the real work"""
        # Create the dialog for the first time
        if self.first_start:
            self.first_start = False
            self.dlg = ConvertisseurAgiDialog()

            # Make sure checkbox is unchecked initially
            self.dlg.checkBox.setChecked(False)
            self.create_form = False

            # Connect the checkbox state pour la création du formulaire
            self.dlg.checkBox.stateChanged.connect(self._toggle_form_creation)

            # Connect the "Select All" button
            self.dlg.pushButton.clicked.connect(self._select_all_layers)

        # Populate the layer list before showing
        self.setup_layer_list()

        # Show the dialog
        self.dlg.show()

        # Run the dialog event loop
        result = self.dlg.exec_()

        # Process result if OK was pressed
        if result:
            # Get the current checkbox state directly from the UI
            # This ensures we have the correct state even if the signal-slot connection failed
            self.create_form = self.dlg.checkBox.isChecked()

            dictionary_path = ""
            custom_afs_name = ""

            if self.create_form:
                # Ask user to choose a name for the .afs file
                from PyQt5.QtWidgets import QInputDialog, QLineEdit

                custom_afs_name, ok = QInputDialog.getText(
                    self.dlg,
                    "Nom du formulaire de saisie",
                    "Veuillez entrer un nom pour le formulaire de saisie:",
                    QLineEdit.Normal
                )

                if not ok or not custom_afs_name:
                    # If user cancels or doesn't enter a name, use default naming
                    custom_afs_name = ""

            else:
                # Only show the form popup if the checkbox is NOT checked
                # Ask user if they want to select a dictionary file
                dict_msg = QMessageBox()
                dict_msg.setIcon(QMessageBox.Question)
                dict_msg.setText("Voulez-vous choisir un formulaire de saisie associé ?")
                dict_msg.setWindowTitle("Sélection du formulaire")
                dict_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
                dict_response = dict_msg.exec_()

                if dict_response == QMessageBox.Yes:
                    # Open file dialog to select dictionary file
                    dictionary_path, _ = QFileDialog.getOpenFileName(
                        self.dlg,
                        "Sélectionner un formulaire de saisie",
                        "",
                        "Dictionary Files (*.afs);;All Files (*)"
                    )

                    # Validate the dictionary file if one was selected
                    if dictionary_path:
                        try:
                            # Read the first few lines of the file to check format
                            with open(dictionary_path, 'r', encoding='iso-8859-1') as f:
                                # Read first 100 characters which should be enough to contain the header
                                file_start = f.read(100)

                                # Check if file starts with XML declaration and contains <afs name
                                if not ('<?xml version' in file_start and '<afs name' in file_start):
                                    # Show error message for invalid dictionary
                                    QMessageBox.critical(
                                        self.dlg,
                                        "Formulaire de saisie invalide",
                                        "Le fichier sélectionné n'est pas un fichier AFS valide.\n"
                                        "Merci de choisir un formulaire de saisie créé par ArpentGIS Expert."
                                    )
                                    dictionary_path = ""  # Reset path since file is invalid
                        except Exception as e:
                            # Show error if we can't read the file
                            QMessageBox.critical(
                                self.dlg,
                                "Error Reading Dictionary",
                                f"Could not read the selected dictionary file:\n{str(e)}"
                            )
                            dictionary_path = ""  # Reset path since file is invalid

        # Now proceed with the conversion, passing the dictionary path
        try:
            self._process_selected_layers(dictionary_path, custom_afs_name)
        except Exception as e:
            # Show error message if processing fails
            QMessageBox.critical(
                self.dlg,
                "Error Processing Layers",
                f"An error occurred during processing:\n{str(e)}"
            )

    def _select_all_layers(self):
        """
        Select or deselect all layers in the list widget.
        Toggles between fully checked and fully unchecked.
        """
        # Check if any layers are currently unchecked
        all_checked = all(
            self.dlg.listWidget.item(i).checkState() == Qt.Checked
            for i in range(self.dlg.listWidget.count())
        )

        # Set the new check state opposite of the current state
        new_state = Qt.Unchecked if all_checked else Qt.Checked

        # Apply the new state to all items
        for i in range(self.dlg.listWidget.count()):
            item = self.dlg.listWidget.item(i)
            item.setCheckState(new_state)

    # Connexion de la case à cocher pour la création du formulaire
    def _toggle_form_creation(self, state):
        """Toggle the form creation state based on the checkbox"""
        self.create_form = state == Qt.Checked

    def setup_layer_list(self):
        """
        Populate the list widget with layers from the current QGIS project.
        All layers are selected by default.
        """
        try:
            # Clear existing items
            self.dlg.listWidget.clear()

            # Get layers from QGIS project
            layers = QgsProject.instance().mapLayers()

            # Populate the list widget
            for layer_id, layer in layers.items():
                # Check if layer is valid and not a temporary/memory layer
                if layer.type() == QgsMapLayer.VectorLayer and not layer.name().startswith('memory:'):
                    # Create a list widget item
                    item = QListWidgetItem(layer.name())

                    # Make item checkable
                    item.setFlags(item.flags() | Qt.ItemIsUserCheckable)

                    # Set it to checked by default (this is the change)
                    item.setCheckState(Qt.Checked)

                    # Add the item to the list widget
                    self.dlg.listWidget.addItem(item)

        except Exception as e:
            print(f"Error setting up layer list: {e}")

    def _process_selected_layers(self, dictionary_path="", custom_afs_name=""):
        """
        Process the layers that were selected in the dialog and export to XML.

        Args:
            dictionary_path (str): Path to the selected dictionary file
            custom_afs_name (str): Custom name for the AFS file when creating a form
        """
        # Create the root element
        doc = minidom.Document()
        root = doc.createElement("document")

        # Prompt user to choose save location first (to get the filename)
        save_path, _ = QFileDialog.getSaveFileName(
            self.dlg,
            "Enregister le fichier AGI",
            "",
            "AGI Files (*.agi)"  # Change filter to show .agi instead of .xml
        )

        # If no path selected, cancel the operation
        if not save_path:
            return

        # Ensure .agi extension
        if not save_path.lower().endswith('.agi'):
            save_path += '.agi'

        # Extract filename without extension
        file_name = os.path.splitext(os.path.basename(save_path))[0]

        # Add name attribute to document
        root.setAttribute("name", file_name)
        root.setAttribute("description", "")
        root.setAttribute("lambert", "")
        root.setAttribute("utm", "")

        software_elem = doc.createElement("Software")
        software_elem.setAttribute("Name", "")
        software_elem.setAttribute("Version", "")
        root.appendChild(software_elem)

        # Locate the section where the dictionary element is created (around line 368)
        dictionary_elem = doc.createElement("dictionary")
        if dictionary_path:
            # Extract just the filename without the path
            dict_filename = os.path.basename(dictionary_path)
            dictionary_elem.setAttribute("fileName", dict_filename)
        elif custom_afs_name:
            # If we're creating a form, use the custom form name with .afs extension
            dictionary_elem.setAttribute("fileName", f"{custom_afs_name}.afs")
        else:
            # Otherwise use the same name as the AGI file with .afs extension
            dictionary_elem.setAttribute("fileName", f"{file_name}.afs")
        root.appendChild(dictionary_elem)

        rasters_elem = doc.createElement("rasters")
        root.appendChild(rasters_elem)

        rasters_elem = doc.createElement("rasters")
        root.appendChild(rasters_elem)

        # Create stats element here (after software, dictionary, and rasters)
        stats_elem = doc.createElement("stats")
        stats_elem.setAttribute("entities", "")  # Empty for now, will update later
        root.appendChild(stats_elem)

        ssf_elem = doc.createElement("ssf")
        ssf_elem.setAttribute("correction", "0")
        root.appendChild(ssf_elem)

        doc.appendChild(root)

        # Collect selected layers
        selected_layers = []
        selected_layer_names = []

        # List to store all entity information
        all_entities = []

        # Create a dictionary to keep track of counters for each class (layer name)
        class_counters = {}

        for i in range(self.dlg.listWidget.count()):
            item = self.dlg.listWidget.item(i)
            if item.checkState() == Qt.Checked:
                layer_name = item.text()

                # Find the actual layer in the QGIS project
                layer = None
                for lyr in QgsProject.instance().mapLayers().values():
                    if lyr.name() == layer_name:
                        layer = lyr
                        break

                if layer and isinstance(layer, QgsVectorLayer):
                    selected_layers.append(layer)
                    selected_layer_names.append(layer_name)

                    # Initialize counter for this class if it doesn't exist
                    if layer_name not in class_counters:
                        class_counters[layer_name] = 1

                    # Determine layer type
                    geom_type = layer.geometryType()
                    if geom_type == QgsWkbTypes.PointGeometry:
                        entity_type = "point"
                    elif geom_type == QgsWkbTypes.LineGeometry:
                        entity_type = "line"
                    elif geom_type == QgsWkbTypes.PolygonGeometry:
                        entity_type = "area"
                    else:
                        entity_type = "unknown"

                    # Add an entity for each feature in the layer
                    features = layer.getFeatures()
                    for feature in features:
                        # Check if feature has a geometry and if it's valid
                        geometry = feature.geometry()
                        if not geometry or geometry.isEmpty():
                            # Skip features without geometry
                            continue

                        # The rest of your existing code for processing features
                        entity_data = {
                            "type": entity_type,
                            "name": layer_name,
                            "counter": class_counters[layer_name]
                        }
                        # Increment counter for this class
                        class_counters[layer_name] += 1

                        # Extract coordinates based on geometry type
                        geometry = feature.geometry()
                        if geometry:
                            # Get the layer's CRS
                            layer_crs = layer.crs()

                            # Create the target CRS (EPSG:4326 - WGS84)
                            wgs84 = QgsCoordinateReferenceSystem("EPSG:4326")

                            # Create a coordinate transform
                            transform = QgsCoordinateTransform(layer_crs, wgs84, QgsProject.instance())

                            # Transform the geometry to WGS84
                            geom_copy = QgsGeometry(geometry)  # This creates a copy of the geometry object

                            # Transform the copied geometry to WGS84
                            geom_copy.transform(transform)

                            # Handle point geometries
                            if entity_type == "point":
                                # Get the transformed point coordinates
                                point = geom_copy.asPoint()

                                # Round to 8 decimal places and store as strings in the dictionary
                                entity_data["x"] = "{:.8f}".format(round(point.x(), 8))  # Longitude
                                entity_data["y"] = "{:.8f}".format(round(point.y(), 8))  # Latitude

                            # Handle line geometries by extracting vertices
                            elif entity_type == "line":
                                # Extract vertices from line geometry
                                vertices = []
                                line = geom_copy.constGet()

                                if line:
                                    # Handle multilinestring (collection of lines)
                                    if line.wkbType() == QgsWkbTypes.MultiLineString or line.wkbType() == QgsWkbTypes.MultiLineStringZ:
                                        # For multi-lines, get only the first line
                                        if line.numGeometries() > 0:
                                            single_line = line.geometryN(0)
                                            for i in range(single_line.numPoints()):
                                                point = single_line.pointN(i)
                                                # Round coordinates to 8 decimal places
                                                x = "{:.8f}".format(round(point.x(), 8))
                                                y = "{:.8f}".format(round(point.y(), 8))
                                                vertices.append({"x": x, "y": y})
                                    else:
                                        # For single lines
                                        for i in range(line.numPoints()):
                                            point = line.pointN(i)
                                            # Round coordinates to 8 decimal places
                                            x = "{:.8f}".format(round(point.x(), 8))
                                            y = "{:.8f}".format(round(point.y(), 8))
                                            vertices.append({"x": x, "y": y})

                                # Store vertices in the entity data
                                entity_data["vertices"] = vertices

                            # Handle polygon geometries by extracting only exterior vertices (ignoring holes)
                            elif entity_type == "area":
                                # Extract vertices from polygon geometry
                                vertices = []
                                polygon = geom_copy.constGet()

                                # Get the exterior vertices regardless of polygon type
                                if polygon:
                                    # Handle multipolygon (collection of polygons)
                                    if polygon.wkbType() == QgsWkbTypes.MultiPolygon or polygon.wkbType() == QgsWkbTypes.MultiPolygonZ:
                                        # For multi-polygons, get only the first polygon's exterior
                                        if polygon.numGeometries() > 0:
                                            single_polygon = polygon.geometryN(0)
                                            # Get the exterior ring of this polygon
                                            exterior_ring = single_polygon.exteriorRing()
                                            if exterior_ring:
                                                for i in range(exterior_ring.numPoints()):
                                                    point = exterior_ring.pointN(i)
                                                    # Round coordinates to 8 decimal places
                                                    x = "{:.8f}".format(round(point.x(), 8))
                                                    y = "{:.8f}".format(round(point.y(), 8))
                                                    vertices.append({"x": x, "y": y})

                                    # Handle single polygon
                                    elif hasattr(polygon, 'exteriorRing'):
                                        # Direct access to exterior ring for single polygons
                                        exterior_ring = polygon.exteriorRing()
                                        if exterior_ring:
                                            for i in range(exterior_ring.numPoints()):
                                                point = exterior_ring.pointN(i)
                                                # Round coordinates to 8 decimal places
                                                x = "{:.8f}".format(round(point.x(), 8))
                                                y = "{:.8f}".format(round(point.y(), 8))
                                                vertices.append({"x": x, "y": y})

                                # Store vertices in the entity data
                                entity_data["vertices"] = vertices

                        # Extract all attributes from the feature
                        attributes = {}
                        fields = layer.fields()
                        for field in fields:
                            field_name = field.name()
                            field_type = field.type()

                            # Get attribute value
                            attr_value = feature[field_name]

                            # Determine attribute type for XML
                            if field_type in [QVariant.Int, QVariant.UInt, QVariant.Double,
                                              QVariant.LongLong]:  # Numeric types
                                attr_type = "numeric"
                            elif field_type == QVariant.DateTime or field_name.lower().startswith(
                                    "date"):  # Date fields or field starting with "date"
                                attr_type = "date"
                            else:  # String and other types
                                attr_type = "text"

                            # Store attribute information
                            attributes[field_name] = {
                                "value": str(attr_value) if attr_value is not None else "",
                                "type": attr_type
                            }

                        # Add attributes to entity data
                        entity_data["attributes"] = attributes

                        all_entities.append(entity_data)

        # Sort entities alphabetically by layer name (class)
        all_entities.sort(key=lambda x: x["name"])

        # Create entity elements in alphabetical order
        for entity_info in all_entities:
            # Create an entity element
            entity_elem = doc.createElement("entity")
            entity_elem.setAttribute("type", entity_info["type"])
            entity_elem.setAttribute("class", entity_info["name"])
            entity_elem.setAttribute("LocalHeightAdjustment", "")

            # Add Antenna element with attributes
            antenna_elem = doc.createElement("Antenna")
            antenna_elem.setAttribute("Type", "")
            antenna_elem.setAttribute("Method", "")
            antenna_elem.setAttribute("Height", "")
            entity_elem.appendChild(antenna_elem)

            # Add data elements based on entity type
            if entity_info["type"] == "point":
                # For point entities, add a data/point element
                data_elem = doc.createElement("data")
                point_elem = doc.createElement("point")

                # Set point attributes
                point_elem.setAttribute("x", entity_info.get("x", ""))
                point_elem.setAttribute("y", entity_info.get("y", ""))
                point_elem.setAttribute("z", "0")  # Always set Z value to 0 for all entities
                point_elem.setAttribute("date", "")
                point_elem.setAttribute("time", "")
                point_elem.setAttribute("pdop", "0")
                point_elem.setAttribute("dgps", "0")
                point_elem.setAttribute("sat", "0")
                point_elem.setAttribute("speed", "0")

                data_elem.appendChild(point_elem)
                entity_elem.appendChild(data_elem)

            elif entity_info["type"] == "line" and "vertices" in entity_info:
                # For line entities, create a polyline element with all vertices
                polyline_elem = doc.createElement("polyline")

                # Add a point element for each vertex
                for vertex in entity_info["vertices"]:
                    point_elem = doc.createElement("point")
                    point_elem.setAttribute("x", vertex["x"])
                    point_elem.setAttribute("y", vertex["y"])
                    point_elem.setAttribute("z", "0")
                    point_elem.setAttribute("date", "")
                    point_elem.setAttribute("time", "")
                    point_elem.setAttribute("pdop", "0")
                    point_elem.setAttribute("dgps", "0")
                    point_elem.setAttribute("sat", "0")
                    point_elem.setAttribute("speed", "0")

                    polyline_elem.appendChild(point_elem)

                # Make sure we append the polyline element directly to the entity element
                entity_elem.appendChild(polyline_elem)

            elif entity_info["type"] == "area" and "vertices" in entity_info:
                # For polygon entities, create a polygon element with all vertices
                polygon_elem = doc.createElement("polygon")

                # Add a point element for each vertex
                for vertex in entity_info["vertices"]:
                    point_elem = doc.createElement("point")
                    point_elem.setAttribute("x", vertex["x"])
                    point_elem.setAttribute("y", vertex["y"])
                    point_elem.setAttribute("z", "0")
                    point_elem.setAttribute("date", "")
                    point_elem.setAttribute("time", "")
                    point_elem.setAttribute("pdop", "0")
                    point_elem.setAttribute("dgps", "0")
                    point_elem.setAttribute("sat", "0")
                    point_elem.setAttribute("speed", "0")

                    polygon_elem.appendChild(point_elem)

                entity_elem.appendChild(polygon_elem)

            else:
                # For all other types, add an empty data element
                data_elem = doc.createElement("data")
                entity_elem.appendChild(data_elem)

            # Add "Name" attribute with class name and counter (the key change!)
            name_attrib = doc.createElement("attrib")
            name_attrib.setAttribute("name", "Name")
            name_attrib.setAttribute("value", f"{entity_info['name']} {entity_info['counter']}")
            name_attrib.setAttribute("type", "text")
            entity_elem.appendChild(name_attrib)

            # Add attribute elements for each entity attribute
            if "attributes" in entity_info:
                for attr_name, attr_data in entity_info["attributes"].items():
                    # Skip adding the Name attribute since we already added it above
                    if attr_name != "Name":
                        attrib_elem = doc.createElement("attrib")
                        attrib_elem.setAttribute("name", attr_name)
                        attrib_elem.setAttribute("value", attr_data["value"])
                        attrib_elem.setAttribute("type", attr_data["type"])
                        entity_elem.appendChild(attrib_elem)

            # Add the entity element to the root
            root.appendChild(entity_elem)

        # Calculate total entities
        total_entities = sum(layer.featureCount() for layer in selected_layers)

        # Update the stats element with the calculated value
        stats_elem.setAttribute("entities", str(total_entities))

        # If no layers selected, show a message
        if not selected_layers:
            self.iface.messageBar().pushMessage(
                "Warning",
                "No layers selected for conversion",
                level=Qgis.Warning
            )
            return

        try:
            # Pretty print the XML with indentation and UTF-8 encoding
            xml_str = doc.toprettyxml(indent="  ", encoding="utf-8").decode('utf-8')

            # Write to file (removing extra blank lines)
            with open(save_path, 'w', encoding='utf-8') as f:
                # Remove extra blank lines while preserving indentation
                lines = [line for line in xml_str.split('\n') if line.strip()]
                f.write('\n'.join(lines))

            # When creating the form file, use the custom name if provided
            if self.create_form:
                # Create an empty AFS form file, using the custom name if provided
                if custom_afs_name:
                    form_path = os.path.join(os.path.dirname(save_path), f"{custom_afs_name}.afs")
                    form_display_name = custom_afs_name
                else:
                    form_path = os.path.splitext(save_path)[0] + '.afs'
                    form_display_name = file_name

                # Create a basic AFS XML structure
                form_doc = minidom.Document()
                afs_root = form_doc.createElement("afs")
                afs_root.setAttribute("name", form_display_name)
                # Removed version attribute and added description and TrackLog instead
                afs_root.setAttribute("description", "")
                afs_root.setAttribute("TrackLog", "0")

                # Add layers section to list all QGIS layers
                layers_elem = form_doc.createElement("layers")
                afs_root.appendChild(layers_elem)

                # Get all vector layers from QGIS project
                all_layers = QgsProject.instance().mapLayers().values()
                vector_layers = [layer for layer in all_layers if isinstance(layer, QgsVectorLayer)]

                # Create collections for each geometry type
                point_layers = []
                line_layers = []
                area_layers = []
                other_layers = []

                # Categorize layers by geometry type
                for layer in vector_layers:
                    geom_type = layer.geometryType()
                    if geom_type == QgsWkbTypes.PointGeometry:
                        point_layers.append(layer)
                    elif geom_type == QgsWkbTypes.LineGeometry:
                        line_layers.append(layer)
                    elif geom_type == QgsWkbTypes.PolygonGeometry:
                        area_layers.append(layer)
                    else:
                        other_layers.append(layer)

                # Sort each collection alphabetically by layer name
                point_layers.sort(key=lambda x: x.name())
                line_layers.sort(key=lambda x: x.name())
                area_layers.sort(key=lambda x: x.name())
                other_layers.sort(key=lambda x: x.name())

                # Combine all sorted layers in the desired order
                sorted_layers = point_layers + line_layers + area_layers + other_layers

                # Now process the sorted layers instead of the original collection
                for layer in all_layers:
                    if isinstance(layer, QgsVectorLayer):
                        # Create layer element
                        layer_elem = form_doc.createElement("layer")
                        layer_elem.setAttribute("name", layer.name())

                        # Determine geometry type
                        geom_type = layer.geometryType()
                        if geom_type == QgsWkbTypes.PointGeometry:
                            type_attr = "point"

                            # Add additional elements only for point layers
                            # Add color element
                            color_elem = form_doc.createElement("color")
                            color_elem.appendChild(form_doc.createTextNode("0;0;0"))
                            layer_elem.appendChild(color_elem)

                            # Add autosave element
                            autosave_elem = form_doc.createElement("autosave")
                            autosave_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(autosave_elem)

                            # Add recfrequency element
                            recfrequency_elem = form_doc.createElement("recfrequency")
                            recfrequency_elem.appendChild(form_doc.createTextNode("1"))
                            layer_elem.appendChild(recfrequency_elem)

                            # Add geosymbol element
                            geosymbol_elem = form_doc.createElement("geosymbol")
                            geosymbol_elem.setAttribute("font", "ArpentGIS")
                            geosymbol_elem.setAttribute("symbol", "101")
                            geosymbol_elem.setAttribute("enabled", "False")
                            layer_elem.appendChild(geosymbol_elem)

                        elif geom_type == QgsWkbTypes.LineGeometry:
                            type_attr = "line"

                            # Add additional elements only for line layers
                            # Add color element
                            color_elem = form_doc.createElement("color")
                            color_elem.appendChild(form_doc.createTextNode("0;0;0"))
                            layer_elem.appendChild(color_elem)

                            # Add autosave element
                            autosave_elem = form_doc.createElement("autosave")
                            autosave_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(autosave_elem)

                            # Add recfrequency element
                            recfrequency_elem = form_doc.createElement("recfrequency")
                            recfrequency_elem.appendChild(form_doc.createTextNode("1"))
                            layer_elem.appendChild(recfrequency_elem)

                            # Add buffer element
                            buffer_elem = form_doc.createElement("buffer")
                            buffer_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(buffer_elem)

                            # Add intervalle_distance element
                            intervalle_elem = form_doc.createElement("intervalle_distance")
                            intervalle_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(intervalle_elem)

                        elif geom_type == QgsWkbTypes.PolygonGeometry:
                            type_attr = "area"

                            # Add additional elements for area layers
                            # Add color element
                            color_elem = form_doc.createElement("color")
                            color_elem.appendChild(form_doc.createTextNode("0;0;0"))
                            layer_elem.appendChild(color_elem)

                            # Add autosave element
                            autosave_elem = form_doc.createElement("autosave")
                            autosave_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(autosave_elem)

                            # Add recfrequency element
                            recfrequency_elem = form_doc.createElement("recfrequency")
                            recfrequency_elem.appendChild(form_doc.createTextNode("1"))
                            layer_elem.appendChild(recfrequency_elem)

                            # Add buffer element
                            buffer_elem = form_doc.createElement("buffer")
                            buffer_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(buffer_elem)

                            # Add intervalle_distance element
                            intervalle_elem = form_doc.createElement("intervalle_distance")
                            intervalle_elem.appendChild(form_doc.createTextNode("0"))
                            layer_elem.appendChild(intervalle_elem)
                            
                        else:
                            type_attr = "unknown"

                        layer_elem.setAttribute("type", type_attr)
                        layer_elem.setAttribute("description", "")

                        # Add attributes section for this layer
                        attributes_elem = form_doc.createElement("attributes")

                        # Get all fields from the layer
                        fields = layer.fields()
                        for field in fields:
                            field_name = field.name()
                            field_type = field.type()

                            # Skip adding the "Name" field to the .afs file
                            if field_name == "Name":
                                continue

                            # Create attribute element
                            attribute_elem = form_doc.createElement("attribute")
                            attribute_elem.setAttribute("name", field_name)
                            attribute_elem.setAttribute("description", "")
                            attribute_elem.setAttribute("DisplayedInObjectList", "False")
                            attribute_elem.setAttribute("DisplayedInPopupList", "True")
                            attribute_elem.setAttribute("UseColorIfNull", "False")
                            attribute_elem.setAttribute("ColorIfNull", "0;0;0")
                            attribute_elem.setAttribute("mandatory", "normal")
                            attribute_elem.setAttribute("visible", "normal")
                            attribute_elem.setAttribute("textcolor", "0;0;0")
                            attribute_elem.setAttribute("repeatable", "True")

                            # Set attribute type and specific properties based on field type
                            if field_type in [QVariant.Int, QVariant.UInt, QVariant.Double, QVariant.LongLong]:
                                attribute_elem.setAttribute("type", "numeric")
                                attribute_elem.setAttribute("nbdigits", "0")
                                attribute_elem.setAttribute("min", "0")
                                attribute_elem.setAttribute("max", "1000")
                                attribute_elem.setAttribute("default", "0")
                                attribute_elem.setAttribute("increment", "0")


                            elif field_type == QVariant.DateTime or field_name.lower().startswith("date"):
                                attribute_elem.setAttribute("type", "date")
                                attribute_elem.setAttribute("default", "")
                                # Add the new required attributes for date fields
                                attribute_elem.setAttribute("auto", "True")
                                attribute_elem.setAttribute("format", "ymd")
                                # Add the new attributes for date fields
                                attribute_elem.setAttribute("auto", "True")
                                attribute_elem.setAttribute("format", "ymd")
                            else:
                                attribute_elem.setAttribute("type", "text")
                                attribute_elem.setAttribute("maxlenght",
                                                            "80")  # Note: typo in maxlenght is intentional to match example
                                attribute_elem.setAttribute("default", "")

                            # Add attribute element to attributes section
                            attributes_elem.appendChild(attribute_elem)

                        # Add attributes element to layer element
                        layer_elem.appendChild(attributes_elem)

                        # Add layer element to layers section
                        layers_elem.appendChild(layer_elem)

                # Add document root
                form_doc.appendChild(afs_root)

                # Write the form file
                try:
                    # Get the XML as a string with iso-8859-1 encoding
                    form_xml = form_doc.toprettyxml(indent="  ", encoding="iso-8859-1").decode('iso-8859-1')

                    # Fix any em dash or other special characters that might be incorrectly processed
                    # This directly replaces any &#8212; (em dash) with a simple hyphen
                    form_xml = form_xml.replace("&#8212;", "-")

                    with open(form_path, 'w', encoding='iso-8859-1') as f:
                        # Remove extra blank lines while preserving indentation
                        lines = [line for line in form_xml.split('\n') if line.strip()]
                        f.write('\n'.join(lines))

                    # Add to success message that will be created below
                    success_message_suffix = f"\nForm file created: {form_path}"

                except Exception as e:
                    # Show error message if writing fails
                    self.iface.messageBar().pushMessage(
                        "Error",
                        f"Failed to write form file: {str(e)}",
                        level=Qgis.Critical
                    )
                    success_message_suffix = ""
            else:
                success_message_suffix = ""

            # Construct a detailed success message
            success_message = f"XML file created successfully:\n"
            success_message += f"Location: {save_path}\n"
            success_message += f"Layers exported: {', '.join(selected_layer_names)}"
            # Add form file info if it was created
            success_message += success_message_suffix

            # Show success message
            self.iface.messageBar().pushMessage(
                "Fichier créé",
                success_message,
                level=Qgis.Success,
                duration=10  # Show message for 10 seconds
            )

        except Exception as e:

            # Show error message if writing fails

            self.iface.messageBar().pushMessage(

                "Error",

                f"Failed to write XML: {str(e)}",

                level=Qgis.Critical

            )
